<?php

namespace App\Http\Controllers;

use App\Jobs\DispatchWhatsappBroadcast;
use App\Models\AutoResponder;
use App\Models\MessageLog;
use App\Models\WhatsappDevice;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Facades\Http;

class WebhookController extends Controller
{
    /**
     * Handle the webhook for when a QR code is generated by the gateway.
     */
    public function handleQrCodeReceived(Request $request)
    {
        $validated = $request->validate([
            'sessionId' => 'required|string|exists:whatsapp_devices,session_id',
            'qrCodeUrl' => 'nullable|string',
        ]);

        Log::info("QR Code request for session: {$validated['sessionId']}");

        $device = WhatsappDevice::where('session_id', $validated['sessionId'])->first();

        // This device should have been created in the 'pending-qr' state already
        if ($device) {
            $device->update([
                'status' => 'scanning', // A more descriptive status
                'qr_code_url' => $validated['qrCodeUrl'],
            ]);
            Log::info("QR Code received and updated for session: {$validated['sessionId']}");
        }

        return response()->json(['status' => 'success']);
    }

    /**
     * Handle the webhook for when a device successfully connects.
     */
    public function handleDeviceConnected(Request $request)
    {
        $validated = $request->validate([
            'sessionId' => 'required|string|exists:whatsapp_devices,session_id',
            'phone' => 'required|string',
        ]);

        $device = WhatsappDevice::where('session_id', $validated['sessionId'])->first();

        if ($device) {
            $device->update([
                'status' => 'connected',
                'phone_number' => $validated['phone'],
                'name' => $device->name ?? 'WhatsApp - ' . substr($validated['phone'], -4), // Preserve existing name
                'qr_code_url' => null, // QR code is no longer needed
            ]);
            Log::info("Device connected for session: {$validated['sessionId']}");
        }

        return response()->json(['status' => 'success']);
    }

    /**
     * Handle the webhook for when a device is disconnected.
     */
    public function handleDeviceDisconnected(Request $request)
    {
        $validated = $request->validate([
            'sessionId' => 'required|string|exists:whatsapp_devices,session_id',
        ]);

        $device = WhatsappDevice::where('session_id', $validated['sessionId'])->first();

        if ($device) {
            $device->update(['status' => 'disconnected']);
            Log::info("Device disconnected for session: {$validated['sessionId']}");
        }

        return response()->json(['status' => 'success']);
    }

    /**
     * Handle incoming messages and trigger auto-responses.
     */
    public function handleIncomingMessage(Request $request)
    {
        $validated = $request->validate([
            'sessionId' => 'required|string|exists:whatsapp_devices,session_id',
            'from' => 'required|string',
            'body' => 'nullable|string',
            'type' => 'required|string',
        ]);

        Log::info("Incoming message from {$validated['from']} on session {$validated['sessionId']}");

        $device = WhatsappDevice::where("session_id", $validated['sessionId'])->first();
        
        if($device) {
            Log::info("Found User {$device->user_id} with Session Specific Auto responder from {$validated['from']} on session {$validated['sessionId']}");
        }
        
        // Get all possible responders for this user
        $allResponders = AutoResponder::where('user_id', $device->user_id)->get();
        if ($allResponders->isEmpty()) {
            return response()->json(['status' => 'ok', 'message' => 'No responders for user']);
        }

        $incomingType = $validated['type'];
        $incomingBody = strtolower(trim($validated['body'] ?? ''));
        $isText = ($incomingType === 'chat');
        $isMedia = in_array($incomingType, ['image', 'video', 'ptt', 'audio', 'document']);

        $foundResponder = null;

        foreach ($allResponders as $responder) {
            // --- 1. Check Reply Condition ---
            if ($responder->reply_condition === 'text_only' && !$isText) continue;
            if ($responder->reply_condition === 'media_only' && !$isMedia) continue;
            
            // At this point, the message type is valid for this responder.
            // Now we check the keyword.
            
            $keyword = strtolower($responder->keyword);

            // --- 2. Check for "Catch-All" Keyword (*) ---
            if ($keyword === '*') {
                $foundResponder = $responder;
                break; // This is a catch-all for this message type, we're done.
            }

            // --- 3. Check for Specific Keyword (only if it's a text message or has a caption) ---
            if ($isText || ($isMedia && !empty($incomingBody))) {
                $isMatch = false;
                switch ($responder->match_type) {
                    case 'exact':
                        $isMatch = ($incomingBody === $keyword);
                        break;
                    case 'contains':
                        $isMatch = (!empty($keyword) && str_contains($incomingBody, $keyword));
                        break;
                    case 'starts_with':
                        $isMatch = str_starts_with($incomingBody, $keyword);
                        break;
                }

                if ($isMatch) {
                    $foundResponder = $responder;
                    break; // Found our match, stop looping
                }
            }
        }

        if ($foundResponder) {
            Log::info("Auto-responder triggered for keyword: '{$foundResponder->keyword}'");
            
            $foundResponder->increment('hit_count');
    
            $log = \App\Models\AutoResponderLog::create([
                'auto_responder_id' => $foundResponder->id,
                'recipient' => str_replace('@s.whatsapp.net', '', $validated['from']),
                'sent_at' => now(),
                'status' => 'attempted',
            ]);
                
            // **This needs to be updated to support media in auto-replies**
            // For now, it only sends text. You would need to add `media_url`
            // to your AutoResponder model to support this.
            
            $this->sendAutoReply(
                $validated['sessionId'], 
                $validated['from'], 
                $foundResponder->response_message,
                null, // **NEW: Add media_url here if you add it to your AutoResponder model**
                $log->id
            );
        }

        return response()->json(['status' => 'ok']);
    }
    
    /**
     * Handle updates to a message's status (sent, delivered, read).
    */

    public function handleMessageStatusUpdate(Request $request)
    {
        $validated = $request->validate([
            'messageId' => 'required|string', 
            'sessionId' => 'required|string|exists:whatsapp_devices,session_id',
            'status' => 'required|string|in:sent,delivered,read,failed',
            'timestamp' => 'required|date',
        ]);

        $log = MessageLog::where('message_id', $validated['messageId'])->first();

        if ($log) {
            // --- Status Hierarchy (Your existing logic is good) ---
            $statusOrder = ['queued' => 0, 'sent' => 1, 'delivered' => 2, 'read' => 3, 'failed' => 4];
            $currentStatusLevel = $statusOrder[$log->status] ?? 0;
            $newStatusLevel = $statusOrder[$validated['status']] ?? 0;

            if ($newStatusLevel < $currentStatusLevel) {
                Log::info("Ignoring stale status update for {$log->message_id}.");
                return response()->json(['status' => 'ignored_stale_update']);
            }
            
            $updateData = ['status' => $validated['status']];

            // --- SIMPLIFIED LOGIC ---
            // We only care about setting timestamps.
            // The 'sent' timestamp is now set by handleMessageSent.
            switch ($validated['status']) {
                case 'delivered':
                    if (!$log->delivered_at) $updateData['delivered_at'] = $validated['timestamp'];
                    break;
                case 'read':
                    if (!$log->read_at) $updateData['read_at'] = $validated['timestamp'];
                    break;
                case 'failed':
                    // This is a safety net. handleMessageFailed should catch most.
                    break;
            }
            
            $log->update($updateData);
            Log::info("Message status updated: {$log->message_id} to {$validated['status']}");

            // --- Analytics for FAILED status (if it comes from here) ---
            if ($validated['status'] === 'failed' && $log->analytics_processed === false) {
                
                if ($log->campaign_id) {
                    $log->campaign?->increment('failed_count');
                    $log->update(['analytics_processed' => true]);
                
                } elseif ($log->scheduled_message_id) {
                    $log->scheduledMessage?->increment('failed_count');
                    $log->update(['analytics_processed' => true]);
                }
            }

            // Auto-responder log (your existing logic is fine)
            if ($log->auto_responder_log_id) {
                \App\Models\AutoResponderLog::find($log->auto_responder_log_id)
                    ?->update(['status' => $validated['status']]);
            }
        }

        return response()->json(['status' => 'ok']);
    }
    // public function handleMessageStatusUpdate(Request $request)
    // {
    //     $validated = $request->validate([
    //         'messageId' => 'required|string', 
    //         'sessionId' => 'required|string|exists:whatsapp_devices,session_id',
    //         'status' => 'required|string|in:sent,delivered,read,failed',
    //         'timestamp' => 'required|date',
    //     ]);

    //     $log = MessageLog::where('message_id', $validated['messageId'])->first();

    //     if ($log) {
    //         // **NEW: Define a status hierarchy**
    //         $statusOrder = [
    //             'queued' => 0,
    //             'sent' => 1,
    //             'delivered' => 2,
    //             'read' => 3,
    //             'failed' => 4, // 'failed' is a high-priority, final state
    //         ];

    //         $currentStatusLevel = $statusOrder[$log->status] ?? 0;
    //         $newStatusLevel = $statusOrder[$validated['status']] ?? 0;

    //         // **FIX 1: Prevent status downgrades**
    //         // If the new status is 'sent' (1) but the current is 'delivered' (2), 'read' (3), or 'failed' (4), ignore it.
    //         if ($newStatusLevel < $currentStatusLevel) {
    //             Log::info("Ignoring stale status update for {$log->message_id}. Current: {$log->status}, New: {$validated['status']}");
    //             return response()->json(['status' => 'ignored_stale_update']);
    //         }
            
    //         // If we are here, the new status is valid.
    //         $updateData = ['status' => $validated['status']];

    //         switch ($validated['status']) {
    //             case 'sent':
    //                 if (!$log->sent_at) $updateData['sent_at'] = $validated['timestamp'];
    //                 break;
    //             case 'delivered':
    //                 if (!$log->delivered_at) $updateData['delivered_at'] = $validated['timestamp'];
    //                 break;
    //             case 'read':
    //                 if (!$log->read_at) $updateData['read_at'] = $validated['timestamp'];
    //                 break;
    //         }
            
    //         $log->update($updateData);
    //         Log::info("Message status updated: {$log->message_id} to {$validated['status']}");

    //         // **FIX 2: Prevent double-counting**
    //         // Only process analytics if we haven't already.
    //         if ($log->analytics_processed === false) {
                
    //             $incrementSent = false;
    //             $incrementFailed = false;

    //             if ($validated['status'] === 'sent') {
    //                 $incrementSent = true;
    //             } elseif ($validated['status'] === 'failed') {
    //                 $incrementFailed = true;
    //             }

    //             if ($log->campaign_id) {
    //                 $campaign = $log->campaign;
    //                 if ($incrementSent) {
    //                     $campaign->increment('sent_count');
    //                     $log->update(['analytics_processed' => true]); // Mark as processed
    //                 } elseif ($incrementFailed) {
    //                     $campaign->increment('failed_count');
    //                     $log->update(['analytics_processed' => true]); // Mark as processed
    //                 }
    //             } elseif ($log->scheduled_message_id) {
    //                 $scheduledMessage = $log->scheduledMessage;
    //                 if ($incrementSent) {
    //                     $scheduledMessage->increment('sent_count');
    //                     $log->update(['analytics_processed' => true]);
    //                 } elseif ($incrementFailed) {
    //                     $scheduledMessage->increment('failed_count');
    //                     $log->update(['analytics_processed' => true]);
    //                 }
    //             }
    //         }

    //         // Auto-responder log (your existing logic is fine)
    //         if ($log->auto_responder_log_id) {
    //             \App\Models\AutoResponderLog::find($log->auto_responder_log_id)
    //                 ?->update(['status' => $validated['status']]);
    //         }
    //     }

    //     return response()->json(['status' => 'ok']);
    // }

    /**
     * Helper function to send a reply via the gateway.
    */
    private function sendAutoReply(string $sessionId, string $to, string $message, ?string $mediaUrl, ?int $autoResponderLogId = null): void
    {
        $recipient = str_replace('@s.whatsapp.net', '', $to);
        $device = WhatsappDevice::where('session_id', $sessionId)->first();
    
        if (!$device) {
             Log::error("Cannot send reply. Device session {$sessionId} not found.");
             return;
        }
    
        DispatchWhatsappBroadcast::dispatch(
            $sessionId, 
            [$recipient], 
            $message,
            $mediaUrl, // **Pass mediaUrl**
            $device->user_id, // Pass the correct User ID
            null,                // Campaign ID
            null,                // Scheduled Message ID
            $autoResponderLogId   // Auto Responder Log ID
        )->onQueue('whatsapp-broadcasts'); // Use a specific queue
    }

    /**
     * NEW: Handle the webhook for when a QR scan times out.
     */
    public function handleQrTimeout(Request $request)
    {
        $validated = $request->validate([
            'sessionId' => 'required|string|exists:whatsapp_devices,session_id',
        ]);

        $device = WhatsappDevice::where('session_id', $validated['sessionId'])->first();

        if ($device && $device->status !== 'connected') {
            $device->update([
                'status' => 'expired', // New status for the frontend
                'qr_code_url' => null,
            ]);
            Log::warning("QR Scan timed out for session: {$validated['sessionId']}");
        }

        return response()->json(['status' => 'success']);
    }

    /**
     * Handle the final message ID update from the gateway.
    */
    public function handleMessageSent(Request $request)
    {
        $validated = $request->validate([
            'tempMessageId' => 'required|string|exists:message_logs,message_id',
            'finalMessageId' => 'required|string',
            'sessionId' => 'required|string',
        ]);

        $log = MessageLog::where('message_id', $validated['tempMessageId'])->first();

        if ($log) {
            // --- THIS IS THE FIX ---
            // 1. Update the ID and set status to 'sent'
            $log->update([
                'message_id' => $validated['finalMessageId'],
                'status' => 'sent',
                'sent_at' => now(),
            ]);

            // 2. Process analytics *here*, where we are 100% sure
            if ($log->analytics_processed === false) {
                
                if ($log->campaign_id) {
                    $log->campaign?->increment('sent_count');
                    $log->update(['analytics_processed' => true]);
                
                } elseif ($log->scheduled_message_id) {
                    $log->scheduledMessage?->increment('sent_count');
                    $log->update(['analytics_processed' => true]);
                }
            }
            
            Log::info("Final message ID updated and marked as 'sent' for log: {$log->id}");
        }

        return response()->json(['status' => 'success']);
    }
    // public function handleMessageSent(Request $request)
    // {
    //     $validated = $request->validate([
    //         'tempMessageId' => 'required|string|exists:message_logs,message_id',
    //         'finalMessageId' => 'required|string',
    //         'sessionId' => 'required|string',
    //     ]);

    //     $log = MessageLog::where('message_id', $validated['tempMessageId'])->first();

    //     if ($log) {
    //         $log->update([
    //             'message_id' => $validated['finalMessageId'], // Update to the real ID
    //         ]);
    //         Log::info("Final message ID updated for log: {$log->id}");
    //     }

    //     return response()->json(['status' => 'success']);
    // }

    /**
     * NEW: Handle immediate send failures from the gateway.
     */
    public function handleMessageFailed(Request $request)
    {
        $validated = $request->validate([
            'tempMessageId' => 'required|string|exists:message_logs,message_id',
            'sessionId' => 'required|string',
            'reason' => 'required|string',
            'errorCode' => 'nullable|string', // **NEW**
            'friendlyError' => 'nullable|string', // **NEW**
        ]);

        $log = MessageLog::where('message_id', $validated['tempMessageId'])->first();

        if ($log) {
            $log->update([
                'status' => 'failed',
                'failure_reason' => $validated['reason'], // Save the error
                'failure_code' => $validated['errorCode'], // **NEW**
                'friendly_error' => $validated['friendlyError'], // **NEW**
            ]);
            
            Log::warning("Message failed to send (gateway error): {$validated['tempMessageId']}. Reason: {$validated['reason']}");
            
            // **NEW: Increment failure count on parent models**
            if ($log->campaign_id) {
                \App\Models\Campaign::find($log->campaign_id)?->increment('failed_count');
            } elseif ($log->scheduled_message_id) {
                \App\Models\ScheduledMessage::find($log->scheduled_message_id)?->increment('failed_count');
            }
        }

        return response()->json(['status' => 'success']);
    }

    /**
     * Fetches the status of all saved and active sessions from the gateway.
     * This is useful for administration and status dashboards.
    */
    public function listAllSessionsFromGateway(Request $request)
    {
        try {
            $gatewayUrl = config('services.whatsapp.gateway_url');
            $response = Http::get("{$gatewayUrl}/sessions");
            
            // Check for successful response and return the JSON data
            if ($response->successful()) {
                return response()->json($response->json());
            }

            // Handle non-successful status codes from the gateway
            return response()->json([
                'error' => 'Failed to retrieve sessions from gateway.',
                'details' => $response->body(),
            ], $response->status());

        } catch (\Exception $e) {
            Log::error('Gateway connection error for GET /sessions:', ['message' => $e->getMessage()]);
            return response()->json([
                'error' => 'Could not connect to the WhatsApp Gateway.',
                'details' => $e->getMessage(),
            ], 503); // Service Unavailable
        }
    }
}