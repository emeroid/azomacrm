<?php

namespace App\Http\Controllers;

use App\Jobs\DispatchWhatsappBroadcast;
use App\Models\AutoResponder;
use App\Models\MessageLog;
use App\Models\WhatsappDevice;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Facades\Http;

class WebhookController extends Controller
{
    /**
     * Handle the webhook for when a QR code is generated by the gateway.
     */
    public function handleQrCodeReceived(Request $request)
    {
        $validated = $request->validate([
            'sessionId' => 'required|string|exists:whatsapp_devices,session_id',
            'qrCodeUrl' => 'nullable|string',
        ]);

        Log::info("QR Code request for session: {$validated['sessionId']}");

        $device = WhatsappDevice::where('session_id', $validated['sessionId'])->first();

        // This device should have been created in the 'pending-qr' state already
        if ($device) {
            $device->update([
                'status' => 'scanning', // A more descriptive status
                'qr_code_url' => $validated['qrCodeUrl'],
            ]);
            Log::info("QR Code received and updated for session: {$validated['sessionId']}");
        }

        return response()->json(['status' => 'success']);
    }

    /**
     * Handle the webhook for when a device successfully connects.
     */
    public function handleDeviceConnected(Request $request)
    {
        $validated = $request->validate([
            'sessionId' => 'required|string|exists:whatsapp_devices,session_id',
            'phone' => 'required|string',
        ]);

        $device = WhatsappDevice::where('session_id', $validated['sessionId'])->first();

        if ($device) {
            $device->update([
                'status' => 'connected',
                'phone_number' => $validated['phone'],
                'name' => $device->name ?? 'WhatsApp - ' . substr($validated['phone'], -4), // Preserve existing name
                'qr_code_url' => null, // QR code is no longer needed
            ]);
            Log::info("Device connected for session: {$validated['sessionId']}");
        }

        return response()->json(['status' => 'success']);
    }

    /**
     * Handle the webhook for when a device is disconnected.
     */
    public function handleDeviceDisconnected(Request $request)
    {
        $validated = $request->validate([
            'sessionId' => 'required|string|exists:whatsapp_devices,session_id',
        ]);

        $device = WhatsappDevice::where('session_id', $validated['sessionId'])->first();

        if ($device) {
            $device->update(['status' => 'disconnected']);
            Log::info("Device disconnected for session: {$validated['sessionId']}");
        }

        return response()->json(['status' => 'success']);
    }

    /**
     * Handle incoming messages and trigger auto-responses.
     */
    public function handleIncomingMessage(Request $request)
    {
        $validated = $request->validate([
            'sessionId' => 'required|string|exists:whatsapp_devices,session_id',
            'from' => 'required|string',
            'body' => 'nullable|string',
            'type' => 'required|string',
        ]);

        Log::info("Incoming message from {$validated['from']} on session {$validated['sessionId']}");

        $device = WhatsappDevice::where("session_id", $validated['sessionId'])->first();
        
        if($device) {
            Log::info("Found User {$device->user_id} with Session Specific Auto responder from {$validated['from']} on session {$validated['sessionId']}");
        }
        
        // Get all possible responders for this user
        $allResponders = AutoResponder::where('user_id', $device->user_id)->get();
        if ($allResponders->isEmpty()) {
            return response()->json(['status' => 'ok', 'message' => 'No responders for user']);
        }

        $incomingType = $validated['type'];
        $incomingBody = strtolower(trim($validated['body'] ?? ''));
        $isText = ($incomingType === 'chat');
        $isMedia = in_array($incomingType, ['image', 'video', 'ptt', 'audio', 'document']);

        $foundResponder = null;

        foreach ($allResponders as $responder) {
            // --- 1. Check Reply Condition ---
            if ($responder->reply_condition === 'text_only' && !$isText) continue;
            if ($responder->reply_condition === 'media_only' && !$isMedia) continue;
            
            // At this point, the message type is valid for this responder.
            // Now we check the keyword.
            
            $keyword = strtolower($responder->keyword);

            // --- 2. Check for "Catch-All" Keyword (*) ---
            if ($keyword === '*') {
                $foundResponder = $responder;
                break; // This is a catch-all for this message type, we're done.
            }

            // --- 3. Check for Specific Keyword (only if it's a text message or has a caption) ---
            if ($isText || ($isMedia && !empty($incomingBody))) {
                $isMatch = false;
                switch ($responder->match_type) {
                    case 'exact':
                        $isMatch = ($incomingBody === $keyword);
                        break;
                    case 'contains':
                        $isMatch = (!empty($keyword) && str_contains($incomingBody, $keyword));
                        break;
                    case 'starts_with':
                        $isMatch = str_starts_with($incomingBody, $keyword);
                        break;
                }

                if ($isMatch) {
                    $foundResponder = $responder;
                    break; // Found our match, stop looping
                }
            }
        }

        if ($foundResponder) {
            Log::info("Auto-responder triggered for keyword: '{$foundResponder->keyword}'");
            
            $foundResponder->increment('hit_count');
    
            $log = \App\Models\AutoResponderLog::create([
                'auto_responder_id' => $foundResponder->id,
                'recipient' => str_replace('@c.us', '', $validated['from']),
                'sent_at' => now(),
                'status' => 'attempted',
            ]);
                
            // **This needs to be updated to support media in auto-replies**
            // For now, it only sends text. You would need to add `media_url`
            // to your AutoResponder model to support this.
            
            $this->sendAutoReply(
                $validated['sessionId'], 
                $validated['from'], 
                $foundResponder->response_message,
                null, // **NEW: Add media_url here if you add it to your AutoResponder model**
                $log->id
            );
        }

        return response()->json(['status' => 'ok']);
    }
    
    /**
     * Handle updates to a message's status (sent, delivered, read).
     */
    public function handleMessageStatusUpdate(Request $request)
    {
        $validated = $request->validate([
            // Use exists validation to ensure the message_id is one we are tracking
            'messageId' => 'required|string', 
            'sessionId' => 'required|string|exists:whatsapp_devices,session_id', // Good for cross-reference
            'status' => 'required|string|in:sent,delivered,read,failed', // Added 'failed'
            'timestamp' => 'required|date',
        ]);

        $log = MessageLog::where('message_id', $validated['messageId'])->first();

        if ($log) {
            $updateData = [
                'status' => $validated['status'],
            ];

            // Set the appropriate timestamp column based on the status
            switch ($validated['status']) {
                case 'sent':
                    // We only update if it was previously not sent (e.g., 'attempted')
                    if (!$log->sent_at) {
                        $updateData['sent_at'] = $validated['timestamp'];
                    }
                    break;
                case 'delivered':
                    if (!$log->delivered_at) {
                        $updateData['delivered_at'] = $validated['timestamp'];
                    }
                    break;
                case 'read':
                    if (!$log->read_at) {
                        $updateData['read_at'] = $validated['timestamp'];
                    }
                    break;
                case 'failed':
                    // We might not have a specific 'failed_at' column, so we just set the status
                    break;
            }
            
            $log->update($updateData);
            Log::info("Message status updated: {$validated['messageId']} to {$validated['status']}");

            if ($log->campaign_id) {
                // This is a Campaign message
                $campaign = $log->campaign;
                if ($validated['status'] === 'sent' && $campaign->sent_count <= $campaign->total_recipients) {

                    $campaign->increment('sent_count');
                } elseif ($validated['status'] === 'delivered') {
                    // Update only if you track delivered specifically. Be careful not to double count!
                } elseif ($validated['status'] === 'failed') {
                    $campaign->increment('failed_count');
                }
            } elseif ($log->scheduled_message_id) {
                // This is a Scheduled Message
                $scheduledMessage = $log->scheduledMessage;
                if ($validated['status'] === 'sent') {
                    $scheduledMessage->increment('sent_count');
                } elseif ($validated['status'] === 'failed') {
                    $scheduledMessage->increment('failed_count');
                }
            }

            // If this message was from an auto-responder, update the parent log too.
            if ($log->auto_responder_log_id) {
                $autoLog = \App\Models\AutoResponderLog::find($log->auto_responder_log_id);
                if ($autoLog) {
                    // Keep the auto-log status in sync with the message log
                    $autoLog->update(['status' => $validated['status']]);
                }
            }
        }

        return response()->json(['status' => 'ok']);
    }

    /**
     * Helper function to send a reply via the gateway.
    */
    private function sendAutoReply(string $sessionId, string $to, string $message, ?string $mediaUrl, ?int $autoResponderLogId = null): void
    {
        $recipient = str_replace('@c.us', '', $to);
        $device = WhatsappDevice::where('session_id', $sessionId)->first();
    
        if (!$device) {
             Log::error("Cannot send reply. Device session {$sessionId} not found.");
             return;
        }
    
        DispatchWhatsappBroadcast::dispatch(
            $sessionId, 
            [$recipient], 
            $message,
            $mediaUrl, // **Pass mediaUrl**
            $device->user_id, // Pass the correct User ID
            null,                // Campaign ID
            null,                // Scheduled Message ID
            $autoResponderLogId   // Auto Responder Log ID
        )->onQueue('whatsapp-broadcasts'); // Use a specific queue
    }

    /**
     * NEW: Handle the webhook for when a QR scan times out.
     */
    public function handleQrTimeout(Request $request)
    {
        $validated = $request->validate([
            'sessionId' => 'required|string|exists:whatsapp_devices,session_id',
        ]);

        $device = WhatsappDevice::where('session_id', $validated['sessionId'])->first();

        if ($device && $device->status !== 'connected') {
            $device->update([
                'status' => 'expired', // New status for the frontend
                'qr_code_url' => null,
            ]);
            Log::warning("QR Scan timed out for session: {$validated['sessionId']}");
        }

        return response()->json(['status' => 'success']);
    }

    /**
     * Handle the final message ID update from the gateway.
    */
    public function handleMessageSent(Request $request)
    {
        $validated = $request->validate([
            'tempMessageId' => 'required|string|exists:message_logs,message_id',
            'finalMessageId' => 'required|string',
            'sessionId' => 'required|string',
        ]);

        $log = MessageLog::where('message_id', $validated['tempMessageId'])->first();

        if ($log) {
            $log->update([
                'message_id' => $validated['finalMessageId'], // Update to the real ID
            ]);
            Log::info("Final message ID updated for log: {$log->id}");
        }

        return response()->json(['status' => 'success']);
    }

    /**
     * NEW: Handle immediate send failures from the gateway.
     */
    public function handleMessageFailed(Request $request)
    {
        $validated = $request->validate([
            'tempMessageId' => 'required|string|exists:message_logs,message_id',
            'sessionId' => 'required|string',
            'reason' => 'required|string',
            'errorCode' => 'nullable|string', // **NEW**
            'friendlyError' => 'nullable|string', // **NEW**
        ]);

        $log = MessageLog::where('message_id', $validated['tempMessageId'])->first();

        if ($log) {
            $log->update([
                'status' => 'failed',
                'failure_reason' => $validated['reason'], // Save the error
                'failure_code' => $validated['errorCode'], // **NEW**
                'friendly_error' => $validated['friendlyError'], // **NEW**
            ]);
            
            Log::warning("Message failed to send (gateway error): {$validated['tempMessageId']}. Reason: {$validated['reason']}");
            
            // **NEW: Increment failure count on parent models**
            if ($log->campaign_id) {
                \App\Models\Campaign::find($log->campaign_id)?->increment('failed_count');
            } elseif ($log->scheduled_message_id) {
                \App\Models\ScheduledMessage::find($log->scheduled_message_id)?->increment('failed_count');
            }
        }

        return response()->json(['status' => 'success']);
    }

    /**
     * Fetches the status of all saved and active sessions from the gateway.
     * This is useful for administration and status dashboards.
    */
    public function listAllSessionsFromGateway(Request $request)
    {
        try {
            $gatewayUrl = config('services.whatsapp.gateway_url');
            $response = Http::get("{$gatewayUrl}/sessions");
            
            // Check for successful response and return the JSON data
            if ($response->successful()) {
                return response()->json($response->json());
            }

            // Handle non-successful status codes from the gateway
            return response()->json([
                'error' => 'Failed to retrieve sessions from gateway.',
                'details' => $response->body(),
            ], $response->status());

        } catch (\Exception $e) {
            Log::error('Gateway connection error for GET /sessions:', ['message' => $e->getMessage()]);
            return response()->json([
                'error' => 'Could not connect to the WhatsApp Gateway.',
                'details' => $e->getMessage(),
            ], 503); // Service Unavailable
        }
    }
}