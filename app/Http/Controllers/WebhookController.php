<?php

namespace App\Http\Controllers;

use App\Jobs\DispatchWhatsappBroadcast;
use App\Models\AutoResponder;
use App\Models\MessageLog;
use App\Models\WhatsappDevice;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Facades\Http;

class WebhookController extends Controller
{
    /**
     * Handle the webhook for when a QR code is generated by the gateway.
     */
    public function handleQrCodeReceived(Request $request)
    {
        $validated = $request->validate([
            'sessionId' => 'required|string|exists:whatsapp_devices,session_id',
            'qrCodeUrl' => 'nullable|url',
        ]);

        $device = WhatsappDevice::where('session_id', $validated['sessionId'])->first();

        // This device should have been created in the 'pending-qr' state already
        if ($device) {
            $device->update([
                'status' => 'scanning', // A more descriptive status
                'qr_code_url' => $validated['qrCodeUrl'],
            ]);
            Log::info("QR Code received and updated for session: {$validated['sessionId']}");
        }

        return response()->json(['status' => 'success']);
    }

    /**
     * Handle the webhook for when a device successfully connects.
     */
    public function handleDeviceConnected(Request $request)
    {
        $validated = $request->validate([
            'sessionId' => 'required|string|exists:whatsapp_devices,session_id',
            'phone' => 'required|string',
        ]);

        $device = WhatsappDevice::where('session_id', $validated['sessionId'])->first();

        if ($device) {
            $device->update([
                'status' => 'connected',
                'phone_number' => $validated['phone'],
                'name' => $device->name ?? 'WhatsApp - ' . substr($validated['phone'], -4), // Preserve existing name
                'qr_code_url' => null, // QR code is no longer needed
            ]);
            Log::info("Device connected for session: {$validated['sessionId']}");
        }

        return response()->json(['status' => 'success']);
    }

    /**
     * Handle the webhook for when a device is disconnected.
     */
    public function handleDeviceDisconnected(Request $request)
    {
        $validated = $request->validate([
            'sessionId' => 'required|string|exists:whatsapp_devices,session_id',
        ]);

        $device = WhatsappDevice::where('session_id', $validated['sessionId'])->first();

        if ($device) {
            $device->update(['status' => 'disconnected']);
            Log::info("Device disconnected for session: {$validated['sessionId']}");
        }

        return response()->json(['status' => 'success']);
    }

    /**
     * Handle incoming messages and trigger auto-responses.
     */
    public function handleIncomingMessage(Request $request)
    {
        $validated = $request->validate([
            'sessionId' => 'required|string|exists:whatsapp_devices,session_id',
            'from' => 'required|string',
            'body' => 'nullable|string',
        ]);

        Log::info("Incoming message from {$validated['from']} on session {$validated['sessionId']}");

        $device = WhatsappDevice::where("session_id", $validated['sessionId'])->first();
        
        if($device) {
            Log::info("Found User {$device->user_id} with Session Specific Auto responder from {$validated['from']} on session {$validated['sessionId']}");
        }
        // Find an auto-responder that matches the incoming message
        // This is a more efficient query than your original code
        $responder = AutoResponder::where('keyword', 'LIKE', '%' . strtolower(trim($validated['body']) . '%' ))
            ->where('user_id', $device->user_id) // if responders are user-specific
            ->first();

        if ($responder) {

            Log::info("Auto-responder triggered for keyword: '{$responder->keyword}'");
                
            // 1. Increment Hit Count on AutoResponder
            $responder->increment('hit_count');
    
            // 2. Log the reply attempt (will be updated with 'sent'/'failed' later)
            // Assuming AutoResponderLog model exists
            $log = \App\Models\AutoResponderLog::create([
                'auto_responder_id' => $responder->id,
                'recipient' => str_replace('@c.us', '', $validated['from']),
                'sent_at' => now(),
                'status' => 'attempted', // Initial status
            ]);
                
            // 3. Send the reply
            // Pass the log ID so the broadcast job/webhook can update the status
            $this->sendReply($validated['sessionId'], $validated['from'], $responder->response_message, $log->id);
        }

        return response()->json(['status' => 'ok']);
    }
    
    /**
     * Handle updates to a message's status (sent, delivered, read).
     */
    public function handleMessageStatusUpdate(Request $request)
    {
        $validated = $request->validate([
            // Use exists validation to ensure the message_id is one we are tracking
            'messageId' => 'required|string|exists:message_logs,message_id', 
            'sessionId' => 'required|string|exists:whatsapp_devices,session_id', // Good for cross-reference
            'status' => 'required|string|in:sent,delivered,read,failed', // Added 'failed'
            'timestamp' => 'required|date',
        ]);

        $log = MessageLog::where('message_id', $validated['messageId'])->first();

        if ($log) {
            $updateData = [
                'status' => $validated['status'],
            ];

            // Set the appropriate timestamp column based on the status
            switch ($validated['status']) {
                case 'sent':
                    // We only update if it was previously not sent (e.g., 'attempted')
                    if (!$log->sent_at) {
                        $updateData['sent_at'] = $validated['timestamp'];
                    }
                    break;
                case 'delivered':
                    if (!$log->delivered_at) {
                        $updateData['delivered_at'] = $validated['timestamp'];
                    }
                    break;
                case 'read':
                    if (!$log->read_at) {
                        $updateData['read_at'] = $validated['timestamp'];
                    }
                    break;
                case 'failed':
                    // We might not have a specific 'failed_at' column, so we just set the status
                    break;
            }
            
            $log->update($updateData);
            Log::info("Message status updated: {$validated['messageId']} to {$validated['status']}");

            // --- CRUCIAL: Update ScheduledMessage/Campaign Analytics ---
            // If the MessageLog model has relationships/fields that link back to 
            // the parent ScheduledMessage or Campaign, this is where you update its counters:
            // e.g., if ($log->scheduledMessage) { $log->scheduledMessage->increment('sent_count'); }
            // This logic depends on your full MessageLog model definition.

            if ($log->campaign_id) {
                // This is a Campaign message
                $campaign = $log->campaign;
                if ($validated['status'] === 'sent' && $campaign->sent_count === 0) {
                    // Prevent counting the 'sent' status multiple times for the same message
                    // We typically count success on 'delivered' or 'sent' if delivery is not tracked.
                    // Let's count success on SENT/DELIVERED and failure on FAILED.
                    $campaign->increment('sent_count');
                } elseif ($validated['status'] === 'delivered') {
                    // Update only if you track delivered specifically. Be careful not to double count!
                } elseif ($validated['status'] === 'failed') {
                    $campaign->increment('failed_count');
                }
            } elseif ($log->scheduled_message_id) {
                // This is a Scheduled Message
                $scheduledMessage = $log->scheduledMessage;
                if ($validated['status'] === 'sent') {
                    $scheduledMessage->increment('sent_count');
                } elseif ($validated['status'] === 'failed') {
                    $scheduledMessage->increment('failed_count');
                }
            }
        }

        return response()->json(['status' => 'ok']);
    }

    /**
     * Helper function to send a reply via the gateway.
     */
    // private function sendReply(string $sessionId, string $to, string $message, ?int $autoResponderLogId = null): void
    // {
    //     $recipient = str_replace('@c.us', '', $to); // Clean the number
    //     $gatewayUrl = config('services.whatsapp.gateway_url');

    //     // 1. Ping the server connection to ensure the client is loaded/kept alive
    //     Http::post("{$gatewayUrl}/sessions/start", [
    //         'sessionId' => $sessionId,
    //     ])->throw(); // Use throw() to catch connection errors immediately

    //     // 2. Dispatch the actual message sending job
    //     SendWhatsappBroadcast::dispatch($sessionId, [$recipient], $message, 3, null, $autoResponderLogId);
    // }

    private function sendReply(string $sessionId, string $to, string $message, ?int $autoResponderLogId = null): void
    {
        $recipient = str_replace('@c.us', '', $to);
        $gatewayUrl = config('services.whatsapp.gateway_url');

        Http::post("{$gatewayUrl}/sessions/start", [
            'sessionId' => $sessionId,
        ])->throw();

        // The Job now takes 7 arguments.
        DispatchWhatsappBroadcast::dispatch(
            $sessionId, 
            [$recipient], 
            $message, 
            3,          // Delay in seconds (4th arg)
            null,       // Campaign ID (5th arg) - Not applicable here
            null,       // Scheduled Message ID (6th arg) - Not applicable here
            $autoResponderLogId // Auto Responder Log ID (7th arg) - Applicable
        );
    }

    /**
     * Fetches the status of all saved and active sessions from the gateway.
     * This is useful for administration and status dashboards.
    */
    public function listAllSessionsFromGateway(Request $request)
    {
        try {
            $gatewayUrl = config('services.whatsapp.gateway_url');
            $response = Http::get("{$gatewayUrl}/sessions");
            
            // Check for successful response and return the JSON data
            if ($response->successful()) {
                return response()->json($response->json());
            }

            // Handle non-successful status codes from the gateway
            return response()->json([
                'error' => 'Failed to retrieve sessions from gateway.',
                'details' => $response->body(),
            ], $response->status());

        } catch (\Exception $e) {
            Log::error('Gateway connection error for GET /sessions:', ['message' => $e->getMessage()]);
            return response()->json([
                'error' => 'Could not connect to the WhatsApp Gateway.',
                'details' => $e->getMessage(),
            ], 503); // Service Unavailable
        }
    }
}